package com.tcc.service;

import java.util.Base64;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import javax.validation.Valid;
import javax.validation.constraints.NotNull;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.validation.annotation.Validated;

import com.google.common.base.Preconditions;
import com.tcc.entity.Produto;
import com.tcc.entity.TipoProduto;
import com.tcc.entity.DTO.ProdutoDto;
import com.tcc.exception.RegistroNaoEncontradoException;
import com.tcc.repository.ClientePreferenciaRepository;
import com.tcc.repository.ItemPedidoRepository;
import com.tcc.repository.ProdutoRepository;
import com.tcc.repository.TipoProdutoRepository;
import com.tcc.repository.specification.ProdutoSpecification;
import com.validation.AoAlterar;
import com.validation.AoInserir;

@Validated
@Service
public class ProdutoService {

    @Autowired
    private ProdutoRepository produtoRepository;

    @Autowired
    private ClientePreferenciaRepository clientePreferenciaRepository;
    
    @Autowired
    private TipoProdutoRepository tipoProdutoRepository;

    @Autowired
    private ItemPedidoRepository itemPedidoRepository;

    public Produto toEntity(ProdutoDto dto) {
        Produto produto = new Produto();
        produto.setDescricao(dto.getDescricao());
        produto.setValor(dto.getValor());
        
        // Converte a imagem de Base64 para byte[]
        if (dto.getImagemBase64() != null) {
            produto.setImagem(Base64.getDecoder().decode(dto.getImagemBase64()));
        }

        // Associa o TipoProduto pelo ID vindo do DTO
        TipoProduto tipoProduto = tipoProdutoRepository.findById(dto.getTipoProdutoId())
            .orElseThrow(() -> new RegistroNaoEncontradoException("TipoProduto não encontrado"));
        
        produto.setTipoProduto(tipoProduto);

        return produto;
    }

    // Modificação no método inserir para aceitar ProdutoDto
    @Validated(AoInserir.class)
    public List<Produto> inserir(@Valid List<ProdutoDto> produtosDto) {

        // Converte cada ProdutoDto para Produto
        List<Produto> produtos = produtosDto.stream()
            .map(this::toEntity) // Converte ProdutoDto para Produto
            .collect(Collectors.toList());

        // Salva os produtos convertidos
        return produtoRepository.saveAll(produtos); 
    }

    @Validated(AoAlterar.class)
    public Produto alterar(@Valid Produto produto) {
        this.buscarPor(produto.getId());
        
        TipoProduto tipoProduto = tipoProdutoRepository.findById(produto.getTipoProduto().getId())
				.orElseThrow(() -> new RegistroNaoEncontradoException("tipoProduto não encontrado"));
		produto.preencher(tipoProduto);
        
        return produtoRepository.save(produto); 
    }

    public void remover(@NotNull(message = "Os ids dos produtos devem ser informados") List<Integer> ids) {
        ids.forEach(id -> {
        	
            this.buscarPor(id);

            validaCliente(id);

            this.produtoRepository.deleteById(id);
        });
    }

    private void validaCliente(Integer id) {
        Preconditions.checkArgument(!clientePreferenciaRepository.existsByProdutoId(id),
                "Não é possível remover produtos com preferências associadas");
        Preconditions.checkArgument(!itemPedidoRepository.existsByClienteId(id),
                "Não é possível remover produtos com itens de pedido associados");
    }

    // Mantida a função de busca por ID como está
    public Produto buscarPor(@NotNull(message = "O código do produto deve ser informado") Integer id) {
        Optional<Produto> clienteEncontrado = produtoRepository.findById(id);

        if (clienteEncontrado.isPresent()) {
            return clienteEncontrado.get();
        }

        throw new RegistroNaoEncontradoException("Produto não encontrado");
    }
    
    public List<Produto> buscarComFiltros(Produto produtoFiltro) {
        Specification<Produto> specification = ProdutoSpecification.comFiltros(produtoFiltro);
        return produtoRepository.findAll(specification);
    }

    public List<Produto> listarTodos() {
        return produtoRepository.findAll();
    }

}
